# 高德納
## 簡歷
### 早年
#### 高德納出生於於美國威斯康辛州密西根湖邊的密爾瓦基。密爾瓦基是一個山靈水秀、人才輩出的地方，諾貝爾獎得主司馬賀（H. A. Simon）也是在這裡出生的。他父親 Ervin Henry Knuth是德裔美國人，母親是 Louise Marie Bohning。父親有研究生學歷，是一個多才多藝的人，星期天在教堂演奏風琴，在自家地下室經營一個小印刷廠，並在高德納就讀的 Milwaukee Lutheran High School中學教簿記。
### 中學時期
#### 高德納在中學時期就已經展現出學術天分，初中二年級，當地的Ziegler糖果公司為了促銷其稱為Giant Bar的一種棒棒糖，在學校中辦了一個比賽，看誰能用Ziegler's Giant Bar中的字母排列組合出最多的單詞。高德納假裝胃疼，在家裡待了兩個星期，利用一部大字典，得出了4,500個單詞，而裁判只掌握了約2,500多個單詞，他的班級贏得冠軍，獲得一台電視機和每人一塊Giant Bar，而他本人則贏得一副雪撬。[2]

### 大學時期
#### 1956年，高德納以各科平均97.5分的創記錄的高分從中學畢業。由於高德納對物理和音樂都很有興趣，他曾猶豫大學要唸物理還是音樂，後來他決定念物理，進入俄亥俄州克利夫蘭的凱斯理工學院（現在併入凱斯西儲大學）攻讀物理。在此時期，他接觸到當時最先進的大型電腦 IBM 650，他讀過了電腦的手冊後，認為自己可以幫IBM 650寫出更好的編譯程式，便動手開始做。

#### 1959年，高德納成了第一屆Engineering and Science Review 期刊的編輯，該期刊是當時最好的工程科學期刊，獲得了國家獎。高德納從主修物理改成主修數學。1960年, 高德納從凱斯理工學院畢業時，由於他的傑出表現，同時獲得學士與碩士學位。

### 博士生研究時期
#### 1960年，高德納進入加州理工學院研究所，研究所二年級時，為私人公司寫編譯器，賺得5,000元美金。1962年1月Addison-Wesley公司的顧問理查·瓦嘎（Richard Varga）請他出版一本有關編譯器的書籍。1963年，高德納獲得加州理工學院數學博士學位，指導教授是數學家馬紹爾·哈爾。

## 學術成就
### 高德納畢業之後留在加州理工學院任教，並在數學與電腦程式設計領域取得多項成就。

### 1966年，當高德納的著作已經長達3000多頁時，他與出版商商定，編纂一部系統地介紹電腦程式設計的巨著《電腦程式設計藝術》。截至2018年12月，該書已經出版了4卷，並對電腦領域產生了深遠的影響。高德納本人預計第5卷將會在2025年完稿[1]。《科學美國人》雜誌曾將該書與愛因斯坦的《相對論》、狄拉克的《量子力學原理》、理查·費曼的《量子電動力學》等書並列為20世紀最重要的12本物理科學類專論書之一。[3]

### 1968年，高德納拒絕了美國國家安全局的工作邀請，受聘成為史丹福大學電腦系教授，直到退休，其間1972—1973年曾經在奧斯陸大學當客座教授。和他的一個學生開發了克努斯-莫里斯-普拉特演算法，該法則使計算機在文章中搜尋一串字元的過程更加連貫。他在擔任該職務期間開發了TEX排版軟體，成為今天大多數科技書籍使用的排版程式。除此之外高德納還在電腦領域作出了多項貢獻，例如LR解析理論（LR parsing theory）、克努斯-莫里斯-普拉特模式（Knuth-Moris-Pratt pattern）等。

### 1979年卡特總統頒與國家科學獎。1996年11月榮獲京都獎。

## 榮譽
### 1971年獲首屆美國計算機協會Grace Murray Hopper獎
### 1973年當選為美國人文與科學院院士
### 1974年獲ACM協會圖靈獎
### 1975年當選為美國國家科學院院士
### 同年榮獲美國數學協會Lester R. Ford獎
### 1979年獲卡特總統頒發美國國家科學獎章
### 1981年當選為美國工程院院士
### 1982年獲電腦先鋒獎（Computer Pioneer Award）
### 1982年成為IEEE榮譽會員
### 1986年榮獲美國數學學會Steele Award
### 1988年獲富蘭克林獎章
### 1994年獲瑞典科學院Adelskold獎
### 1995年獲IEEE馮·紐曼獎
### 1996年獲Inamori基金會京都先進技術獎（Kyoto Prize for Advanced Technology）

## 編譯器遞迴測試
### 是一種由電腦科學家高德納提出，用來評價ALGOL 60程式語言實現的手段。該測試的目的是辨識出能夠正確實現「遞迴和非本地參照」的編譯器。

### Knuth的例子
```
begin
real procedure A (k, x1, x2, x3, x4, x5);
value k; integer k;
    begin
        real procedure B;
        begin k:= k - 1;
        B:= A := A (k, B, x1, x2, x3, x4);
    end;
    if k <= 0 then A:= x4 + x5 else B;
end;
outreal (A (10, 1, -1, -1, 1, 0));
end;
```
### 這將形成一棵由B呼叫訊框組成的呼叫樹，包含了每一B呼叫訊框和巢狀的A呼叫訊框，每一訊框均含有相應B呼叫產生時的k值副本。試圖在紙上演算出最後結果可能是徒勞的，在原文中高德納推測答案是-121，但正確的結果是-67， 附錄里有一篇由查爾斯H林賽審校的論文，其中包含一個帶有不同初始值的表格。 對於較大的[來源請求]k[來源請求]值，即使是現代電腦也會很快用完所有堆疊空間。

### 說明
#### 巢狀函數定義 ：由於B 是在A 的函數體中實現，B 的函數體就有權限訪問A 的局部變數——例如最明顯的k 值，以及x1,x2,x3,x4,x5 。這對於ALGOL的後繼語言Pascal來說是非常簡單的，但在其他主要的ALGOL後繼語言是不可能實現的，例如C語言（但C語言具有取位址運算子&，可以向任意函數傳遞局部變數的位址，所以這是可以換種方式實現的）
#### 函數參照 ：在遞迴函數呼叫A(k,B,x1,x2,x3,x4)中的B 不是對B的呼叫，而是對B 的參照，只有像x4 或x5 一樣出現在語句A:=x4+x5中時才會真正呼叫B 。與前述迥異，這在C語言中是非常容易實現的，但在多個Pascal的實作版本中是不可能完成的（儘管ISO 7185標準已經支援函數作為參數）。其實只需要將參照的函數集在前文中聲明（此例中只有B），就可以變相實現了。
#### 常數/函數的二元論 ：A中的X1-X5 可能是數值常數或函數 B 的參照，為此，表達式 X4 + X5必須能夠處理這兩種情況，猶如x4 和X5的 被實際參數所取代一樣。（ 按名呼叫 ）。相比起動態型別語言，對於靜態型別語言而言這可能是更棘手的問題。標準的解決辦法是對A 函數的主呼叫重新解釋 常數1，0，-1，把它們看作是返回1、0、-1的不帶參數的函數 。
#### 所有這些都不是該測試的主要意義，他們僅僅是測試的先決條件。該測試的真正意義在於能否將對B函數的另一個參照定位到正確的B的實例上去——另一個同樣能夠同樣訪問到原生的A的參照。一個所謂的「男孩」編譯器，（可能）會使得B總是訪問最頂層的A呼叫訊框。

參考連結
https://zh.wikipedia.org/zh-tw/%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%92%E5%BD%92%E6%B5%8B%E8%AF%95

https://zh.wikipedia.org/zh-tw/%E9%AB%98%E5%BE%B7%E7%BA%B3
